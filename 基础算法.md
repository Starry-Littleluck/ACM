# 基础算法

[TOC]

> [!NOTE]
>
> 代码模板                  
>
> `````cpp
> #include<bits/stdc++.h>
> using namespace std;
> const int N=1e5+10;
> const int mod=1e9+7;
> #define VI vector<int>
> void solve(){
> 
> }
> int main(){
> 	int t=1;
> 	//cin>>t;
> 	while(t--)solve();
>     return 0;
> }
> `````
>

> [!tip]
>
> 对于a%b的结果本质是a-a/b*b
>
> 如-10%3=-1；10%3=1；10%-3=1；-10%-3=-1；
>
> 

# 1.高精度加法

高精度加法是通过一个数组来存储每一位，然后再按正常的加法进行相加，个位加个位，十位加十位，...,有进位加进位。但是对于相加的两个数字，我们不能够直接去按正序存储，我们应该倒序存储，然后实现相加,最后我们还有倒序输出才是正解。

`````cpp
VI a,b,c;
void add(string sa,string sb){			//sa和sb为相加的两个数字，因int存不下，所有用数组存
    for(int i=sa.size()-1;~i;i--)a.push_back(sa[i]-'0');	//将数字倒序存进a中
    for(int i=sb.size()-1;~i;i--)b.push_back(sb[i]-'0');	//将数字倒序存进b中
    int t=0,i=0;
    for(i=0;i<min(a.size(),b.size());i++){
        t+=a[i]+b[i];				//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);			//存入相加的对应位上的余数
        t/=10;						//存上进位
    }
    while(i<a.size()){
        t+=a[i];					//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);			//存入相加的对应位上的余数
        t/=10;						//存上进位
        i++;
    }
    while(i<b.size()){
        t+=b[i];					//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);			//存入相加的对应位上的余数
        t/=10;						//存上进位
        i++;
    }
    if(t)c.push_back(t);			//最后再看看t是否为0，来判断是否要再加一位
}
`````

> [!tip]
>
> 在C++中，`~i`表示对变量`i`进行**按位取反**操作。具体表现为：将`i`的二进制每一位（包括符号位）取反（0变1，1变0）。
> 对于**有符号数**其数学规律可总结为：`~i = -i - 1`;
> 对于**无符号数**其数学规律课总结为：`~i = (2ⁿ - 1) - i`。
>
> ### 原理解析
>
> **按位取反操作** 是对一个整数的每一位二进制数进行取反，即将0变为1，1变为0。这一操作适用于所有整数类型，但处理方式会因数的符号（有符号还是无符号）而有所不同。
>
> #### 正数的按位取反
>
> 对于正数，按位取反操作直接对其二进制表示进行取反。例如：
>
> - **十进制5** ：二进制表示为`00000101`
> - **按位取反** ：`11111010`
> - **十进制结果** ：-6（在**补码**表示下）
>
> 这是因为计算机中的整数通常采用补码表示法，对于正数，其补码与其原码相同。取反后的结果加上1（即补码的求法）会得到对应的负数。
>
> #### 负数的按位取反
>
> 对于负数，按位取反同样是对二进制表示进行取反，但需要注意的是，负数在计算机中是以补码形式存储的。例如：
>
> - **十进制-2** ：二进制补码表示为`11111110`
> - **按位取反** ：`00000001`
> - **十进制结果** ：1
>
> 这里的关键在于补码的性质：负数的补码是其绝对值的二进制表示取反后加1。因此，取反后再加1会恢复到原来的正数。
>
> #### 无符号数的按位取反
>
> 对于无符号数，按位取反也是直接对每一位进行取反，但不会考虑符号位。例如：
>
> - **无符号数5** （假设8位）：二进制表示为`00000101`
> - **按位取反** ：`11111010`
> - **十进制结果** ：250（在无符号8位表示下）
>
> 无符号数没有符号位的概念，因此取反后的结果仍然是一个有效的无符号数。

# 2.高精度减法

这个与高精度加法相似，就是要判断是前者大还是后者大，来考虑是否输出负号和交换顺序

```cpp
VI a,b,c;
void sub(string sa,string sb){	//sa和sb为相加的两个数字，因int存不下，所有用数组存
    if(sa.size()<sb.size()||(sa.size()==sb.size()&&sa<sb)){cout<<'-';swap(sa,sb);}	//保证大数在前，用大数减小树
    for(int i=sa.size()-1;~i;i--)a.push_back(sa[i]-'0');	//将数字倒序存进a中
    for(int i=sb.size()-1;~i;i--)b.push_back(sb[i]-'0');	//将数字倒序存进b中
    int i=0;
    for(i=0;i<b.size();i++){
        if(a[i]<b[i])a[i+1]--,a[i]+=10;						//如果大数的该位小就先借位
        c.push_back(a[i]-b[i]);
    }
    while(i<a.size()) {						//将剩余的a中的位数存进去
        if(a[i]<0){							//如果大数的该位被借位成了负数就要先借位       这个很重要
            a[i+1]--;
            a[i]+=10;
        }
        c.push_back(a[i++]);
        }
    //因为相减，所以可能出现前面多个零的情况，因此要去除前导零
    while(c.size()-1!=0&&!c.back())c.pop_back();
}
```

# 3.高精度乘法

高精度乘法的核心是模拟手工竖式乘法，逐位相乘和错位累加，即用双重循环遍历两个乘数的每一位，执行`a[i] * b[j]`，并将结果累加到乘积数组的`c[i+j]`位置，==注意要对c[i+j]处理进位的情况==，最后再去除前导零。

```cpp
VI a,b,c;
void mul(string sa,string sb){
    for(int i=sa.size()-1;~i;i--)a.push_back(sa[i]-'0');		//将数字倒序存进a中
    for(int i=sb.size()-1;~i;i--)b.push_back(sb[i]-'0');		//将数字倒序存进b中
    c.resize(a.size()+b.size()+1);
    for(int i=0;i<a.size();i++){
        for(int j=0;j<b.size();j++){
            c[i+j]+=a[i]*b[j];				//存乘积
            c[i+j+1]+=c[i+j]/10;			//存进位
            c[i+j]%=10;						//存余数
        }
    }
    while(c.size()>1&&!c.back())c.pop_back();		//去除前导零
}
```

# 4.高精度除法

高精度除法的核心是模拟手工竖式除法

## 高精度除以低精度

从被除数的最高位开始，逐位进行除法运算。具体做法是，将当前的余数乘以 10 再加上当前位的数字，然后用这个结果除以除数，得到商的当前位，同时更新余数，注意去除前导零。

```cpp
VI a,b,c;
void div(string sa,int b){
    for(int i=0;i<sa.size();i++)a.push_back(sa[i]-'0');		//将被除数存进a中
    c.resize(a.size());
    long long t=0;
    for(int i=0;i<a.size();i++){
       t=t*10+a[i];		//存被除数
       c[i]=t/b;		//存商
       t%=b;			//存余数
    }
    while(c.size()>1&&!c[0])c.erase(c.begin());		//去除前导零
}

```

# 5.二分查找

二分查找（Binary Search）是一种在**有序数组**中快速查找目标元素的高效算法。
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值，其时间复杂度为 **O(log n)**。
这个一般是最小求最大，最大求最小的情况下用的多

## **核心原理**

1. **有序前提**：数组必须已排序（升序或降序）。
2. 分治策略：通过不断缩小搜索范围，每次比较中间元素与目标值：
   - 若中间元素等于目标 → 查找成功。
   - 若中间元素小于目标 → 在右半部分继续查找。
   - 若中间元素大于目标 → 在左半部分继续查找。

> [!tip]
>
> 在c++的STL库中有提供:
> `lower_bound(begin, end, value, cmp)`来查找第一个==大于等于==value的值;
> `upper_bound(begin, end, value, cmp)`来查找第一个==大于==value的值。
>
> 还有这两个函数的返回值返回的是查找到的值的地址，不是值。
>
> ### 参数列表
>
> 1. **起始迭代器（`begin`）**
>    表示搜索范围的起始位置，通常为容器（如`vector`、`array`等）的`begin()`迭代器。需与`end`共同定义左闭右开区间`[begin,end)`。
> 2. **结束迭代器（`end`）**
>    表示搜索范围的结束位置，通常为容器的`end()`迭代器。若容器为空或未找到目标值，函数返回此迭代器。
> 3. **目标值（`value`）**
>    需要查找的元素值。其类型必须与容器元素的类型兼容，或可通过隐式转换匹配。例如，在`vector<int>`中查找整数时，`value`应为`int`类型。
> 4. **比较函数（`cmp`，可选）**
>    自定义比较规则的回调函数或函数对象，用于定义元素的排序逻辑。默认使用`<`运算符进行比较。若容器按降序排列，需显式传递`greater<type>()`等函数对象以匹配实际排序方式
>
> ### 举例
>
> ```cpp
>   int a[10]={0,1,2,3,4,5,6,7,8,9};
>   int t=*lower_bound(a,a+10,5);	//t=5
>   t=*upper_bound(a,a+10,5);		//t=6
>   vector<int>b{0,1,2,3,4,5,6,7,8,9};
>   t=*lower_bound(b.begin(),b.end(),5);		//t=5
>   t=*upper_bound(b.begin(),b.end(),5);		//t=6
> ```
>
> 

## 二分查找各个模板

### 模板1

当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
```cpp
int find(int l, int r)
{
    while (l < r)	//l==r时结束
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

### 模板2

当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。

```cpp
int find(int l, int r)
{
    while (l < r)	//l==r是结束
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 模板3

```cpp
int find(){
  int l=0,r=n+1;	//开区间
  while(l+1<r){ 	//l+1=r时结束
    int mid=l+r>>1;
    if(check(mid)) r=mid; 	//最小化
    else l=mid;
  }
  return check(r) ? r : -1;
}
```

### 模板4

```cpp
int find(){
  int ans=0;
  int l=1,r=n; 		//闭区间
  while(l<=r){ 		//l=r+1时结束
    int mid=l+r>>1;
    if(check(mid)) ans=mid,r=mid-1; 	//最小化
    else l=mid+1;
  }
  return check(ans) ? ans : -1;
}
```

# 6.前缀和(Prefix Sum)

**前缀和**:序列的前 i项之和

即$$s[i]=\sum_{i=1}^ia[i]=s[i-1]+a[i]$$

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422210643057-888332746.png)

```cpp
int a[1005],s[1005];
void ps(){
    for(int i=1;i<=n;i++){
        cin>>a[i];			//输入值
        s[i]=s[i-1]+a[i];	//用s数组来存储前缀和
    }
}
```



**区间和**=s[r]-s[l-1]

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422210944830-290731920.png)

```cpp
int qj(int l,int r){
    return s[r]-s[l-1];
}
```

## 拓展

> # 1.二维前缀和
>
> 前缀和=上区+左区-左上区+当前格
> $$S_{i,j}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}$$
>
> ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422211735930-1648355429.png)
>
> ```cpp
> int a[1005][1005],s[1005][1005];
> void ps(){
> for(int i=1;i<=m;i++)
> for(int j=1;j<=n;j++){
> s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
> }
> }
> ```
>
> 
>
> 区间和=全区-上区-左区+左上区
> $$S_{ab,ij}=S_{i,j}-S_{a-1,j}-S_{i,b-1}+S_{a-1,b-1}$$
>
> ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422211855802-1121457912.png)
>
> ```cpp
> int qj(int a,int b,int i,int j){
> return s[i][j]-s[a-1][j]-s[i][b-1]+s[a-1][b-1];
> }
> ```
>
> # 2.树上前缀和
>
> 题目多次询问树上的一些路径的权值和，就要考虑树上前缀和了。
> 这里树上的路径可以类比一维序列的区间。
>
> 对于树上前缀和可以分成两类
>
> - **点前缀和**
>   设$s[i]$表示从**根节点到节点i**的点权和。
>   先自顶向下计算出前缀和 s[i],然后用 前缀和 拼凑$(x,y)$的路径和。
>   $$s[x]+s[y]-s[lca]-s[fa[lca]]$$
>
>   ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422213652303-312307895.png)
>
> - **边前缀和**
>
>   设$s[i]$表示从**根节点到节点i**的边权和。
>   先自顶向下计算出前缀和 s[$i]$,然后用 前缀和 拼凑$(x,y)$的路径和。
>   $$s[x]+s[y]-2\cdot s[lca]$$
>
>   这个可以看作是将边权下移给了节点
>
>   ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422213734809-1994845738.png)
>
>   如果要求树上前缀和要先了解lca(最近公共祖先)。
>   
>   > # 最近公共祖先（倍增算法）
>   >
>   > ==定义：两个节点的最近公共祖先 (Lowest Common Ancestor, LCA) 就是这两个点的公共祖先里面，离他们最近的那个。==
>   >
>   > 倍增算法是最经典的求 LCA 算法
>   >
>   > ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250422214551496-1461430636.png)
>   >
>   > **dep[u]**存u点的深度。
>   > **fa[u]\[i] **存从 u 点向上跳 2$^\mathrm{i}$层的祖先结点。i=0,1,2,3....
>   > 例如，从节点9向上跳$$2^0$$层的祖先是3，跳$$2^1$$层的祖先是6，跳2^2^层的祖先是1，跳2^3^层的祖先是0
>   >
>   > ## 1.**dfs一遍，创建ST表**
>   >
>   > **倍增递推，fa[u]\[i] = fa[fa[u]\[i-1]]\[i-1]**
>   >
>   > ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250423191726883-1283498586.png)
>   >
>   > |      | 0    | 1    | 2    | 3    | …    | 19   |
>   > | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
>   > | 1    | 0    | 0    | 0    | 0    | …    | 0    |
>   > | 5    | 1    | 0    | 0    | 0    | …    | 0    |
>   > | 2    | 5    | 1    | 0    | 0    | …    | 0    |
>   > | 6    | 5    | 1    | 0    | 0    | …    | 0    |
>   > | 3    | 6    | 5    | 0    | 0    | …    | 0    |
>   > | 9    | 3    | 6    | 1    | 0    | …    | 0    |
>   >
>   > ## 2.**利用ST表求LCA**
>   >
>   > （1）第一阶段，将u, v跳到同一层
>   > 设u, v两点的深度之差为y，将y进行二进制拆分，可以将y次游标跳跃优化为“y的二进制表示所含1的个数”次游标跳跃，一定能跳到同一层。
>   > 例如，y = 1019（0…01111111011）= 512 + 256 + … + 8 + 2 + 1，不越界则跳，共跳9次到达。
>   >
>   > （2）第二阶段，将u, v一起跳到LCA的下一层
>   > 从最大的i开始循环尝试，一直尝试到0，最后游标u, v一定能停在LCA的下一层。
>   > 例如，y = 1019（0…01111111011）两游标会跳512 + 256 + … + 8 + 2 = 1018层，共跳8次到达LCA的下一层。
>   >
>   > ```cpp
>   > VI dep(30), e[1010]; 			// dep: 每个节点的深度，e: 邻接表存储树的边
>   > VI<VI> fa(1010, VI(20, 0)); 	// fa[u][i]: 节点 u 的第 2^i 个祖先
>   > 
>   > // 深度优先搜索 (DFS) 初始化节点的深度和祖先信息
>   > void dfs(int u, int father) {
>   >     dep[u] = dep[father] + 1; 	// 当前节点 u 的深度为父节点的深度加 1
>   >     fa[u][0] = father; 			// 节点 u 的第 1 个祖先是 father
>   >     for (int i = 1; i <= 19; i++) {
>   >         // 通过动态规划计算 fa[u][i]，即节点 u 的第 2^i 个祖先
>   >         fa[u][i] = fa[fa[u][i - 1]][i - 1];
>   >     }
>   >     // 遍历节点 u 的所有邻接节点
>   >     for (int v : e[u]) {
>   >         if (v != father) { // 避免回到父节点
>   >             dfs(v, u); // 递归处理子节点
>   >         }
>   >     }
>   > }
>   > 
>   > // 求解两个节点 u 和 v 的最近公共祖先 (LCA)
>   > int lca(int u, int v) {
>   >     if (dep[u] < dep[v]) swap(u, v); 	// 确保 u 的深度不小于 v
>   >     // 将 u 提升到与 v 相同的深度
>   >     for (int i = 19; i >= 0; i--) {
>   >         if (dep[fa[u][i]] >= dep[v]) {
>   >             u = fa[u][i];
>   >         }
>   >     }
>   >     if (u == v) return v; 				// 如果 u 和 v 相同，则返回 u 或 v
>   >     // 同时向上跳跃，直到找到最近公共祖先
>   >     for (int i = 19; i >= 0; i--) {
>   >         if (fa[u][i] != fa[v][i]) {
>   >             u = fa[u][i];
>   >             v = fa[v][i];
>   >         }
>   >     }
>   >     return fa[u][0]; // 返回最近公共祖先
>   > }
>   > ```
>
>   树上前缀和需要另开一个数组来存储该点的前缀和，比如我下面开了一个数组s来存储前缀和，s[u]表示u点到根节点的和（可以是点和，也可以是边权和）
>   
>   ## 点前缀和
>
> ```cpp
> // 定义全局变量
> VI dep(30), e[1010], s(1010), a(1010); // dep: 每个节点的深度，e: 邻接表存储树的边，s: 前缀和数组，a: 节点权值
> VI<VI> fa(1010, VI(20, 0)); // fa[u][i]: 节点 u 的第 2^i 个祖先
> 
> // 深度优先搜索 (DFS) 初始化节点的深度和前缀和
> void dfs(int u, int father) {
>     s[u] = a[u] + s[father]; // 当前节点的前缀和 = 当前节点权值 + 父节点的前缀和
>     dep[u] = dep[father] + 1; // 当前节点 u 的深度为父节点的深度加 1
>     fa[u][0] = father; // 节点 u 的第 1 个祖先是 father
>     for (int i = 1; i <= 19; i++) {
>         // 通过动态规划计算 fa[u][i]，即节点 u 的第 2^i 个祖先
>         fa[u][i] = fa[fa[u][i - 1]][i - 1];
>     }
>     // 遍历节点 u 的所有邻接节点
>     for (int v : e[u]) {
>         if (v != father) { // 避免回到父节点
>             dfs(v, u); // 递归处理子节点
>         }
>     }
> }
> 
> // 求解两个节点 u 和 v 的最近公共祖先 (LCA)
> int lca(int u, int v) {
>     if (dep[u] < dep[v]) swap(u, v); // 确保 u 的深度不小于 v
>     // 将 u 提升到与 v 相同的深度
>     for (int i = 19; i >= 0; i--) {
>         if (dep[fa[u][i]] >= dep[v]) {
>             u = fa[u][i];
>         }
>     }
>     if (u == v) return v; // 如果 u 和 v 相同，则返回 u 或 v
>     // 同时向上跳跃，直到找到最近公共祖先
>     for (int i = 19; i >= 0; i--) {
>         if (fa[u][i] != fa[v][i]) {
>             u = fa[u][i];
>             v = fa[v][i];
>         }
>     }
>     return fa[u][0]; // 返回最近公共祖先
> }
> 
> // 计算两个节点 u 和 v 的路径权值和
> int qj(int u, int v) {
>     int t = lca(u, v); // 找到 u 和 v 的最近公共祖先
>     // 路径权值和 = u 的前缀和 + v 的前缀和 - 最近公共祖先的前缀和 - 最近公共祖先父节点的前缀和
>     return s[u] + s[v] - s[t]-s[fa[t][0]];
> }
> ```
>
> ## 边前缀和
>
> ```cpp
> // 定义全局变量
> VI dep(30), s(1010), a(1010); // dep: 每个节点的深度, s: 前缀和数组, a: 节点权值数组
> vector<array<int, 2>> e[1010]; // 邻接表存储树的边，array<int, 2> 表示边的目标节点和权值
> VI<VI> fa(1010, VI(20, 0)); // fa[u][i]: 节点 u 的第 2^i 个祖先
> 
> // 深度优先搜索 (DFS) 初始化节点的深度和前缀和
> void dfs(int u, int father) {
>     dep[u] = dep[father] + 1; // 当前节点 u 的深度为父节点的深度加 1
>     fa[u][0] = father; // 节点 u 的第 1 个祖先是 father
>     for (int i = 1; i <= 19; i++) {
>         // 通过动态规划计算 fa[u][i]，即节点 u 的第 2^i 个祖先
>         fa[u][i] = fa[fa[u][i - 1]][i - 1];
>     }
>     // 遍历节点 u 的所有邻接节点
>     for (auto [v, x] : e[u]) { // v: 邻接节点, x: 边权值
>         if (v != father) { // 避免回到父节点
>             s[v] = s[u] + x; // 当前节点的前缀和 = 父节点的前缀和 + 边权值
>             dfs(v, u); // 递归处理子节点
>         }
>     }
> }
> 
> // 求解两个节点 u 和 v 的最近公共祖先 (LCA)
> int lca(int u, int v) {
>     if (dep[u] < dep[v]) swap(u, v); // 确保 u 的深度不小于 v
>     // 将 u 提升到与 v 相同的深度
>     for (int i = 19; i >= 0; i--) {
>         if (dep[fa[u][i]] >= dep[v]) {
>             u = fa[u][i];
>         }
>     }
>     if (u == v) return v; // 如果 u 和 v 相同，则返回 u 或 v
>     // 同时向上跳跃，直到找到最近公共祖先
>     for (int i = 19; i >= 0; i--) {
>         if (fa[u][i] != fa[v][i]) { // 如果 u 和 v 的第 2^i 个祖先不同
>             u = fa[u][i]; // u 跳到第 2^i 个祖先
>             v = fa[v][i]; // v 跳到第 2^i 个祖先
>         }
>     }
>     return fa[u][0]; // 返回最近公共祖先
> }
> 
> // 计算两个节点 u 和 v 的路径权值和
> int qj(int u, int v) {
>     int t = lca(u, v); // 找到 u 和 v 的最近公共祖先
>     // 路径权值和 = u 的前缀和 + v 的前缀和 - 2*最近公共祖先的前缀和
>     return s[u] + s[v] - 2*s[t];
> }
> ```
>

# 7.差分

对于一个给定的序列 a，它的差分序列 b 定义为：
$$b[1] = a[1], \quad b[i] = a[i] - a[i - 1], \quad (2 \leq i \leq n)$$
b 是 a 的差分序列，a 是 b 的前缀和序列，差分与前缀和是一对互逆运算。
$$
a[1] = b[1],\\
a[2] = b[2] + a[1] = b[2] + b[1],\\
a[3] = b[3] + a[2] = b[3] + b[2] + b[1]
$$
**差分思想**
把序列 a 的区间 [l, r] 加 d，等价于其差分序列 b 的点 b[l] 加 d，点 b[r + 1] 减 d，其他位置不变。即把原序列的**区间操作**转化为差分序列的**两点操作**。多次区间操作完成后，再利用前缀和还原。时间复杂度从 **O(n^2^) **降为**O(n)**。
a: 1 2 3 1 2 3
[2, 5] +1: 1 3 4 2 3 3
[1, 4] +2: 3 5 6 4 3 3



b: 1 1 1 -2 1 1
[2, 5] +1: 1 2 1 -2 1 0
[1, 4] +2: 3 2 1 -2 -1 0
还原: 3 5 6 4 3 3

```cpp
int n, m, a[N], b[N];
cin >> n >> m;
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    b[i] = a[i] - a[i-1];  // 初始化差分数组
}
while (m--) {
    int l, r, c;
    cin >> l >> r >> c;
    b[l] += c;             // 左端点加c
    b[r+1] -= c;           // 右端点后一位减c
}
for (int i = 1; i <= n; i++) {
    b[i] += b[i-1];        // 前缀和还原数组
    cout << b[i] << " ";
}
```

## 拓展

> # 二维差分
>
> **核心操作**：对子矩阵 `(x1, y1)` 到 `(x2, y2)` 内的所有元素统一加减值 `c`
> **实现步骤**：
>
> 1. **初始化差分矩阵**：`b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1]`。
>
> 2. 子矩阵修改
>
>    ：
>
>    - `b[x1][y1] += c`
>    - `b[x2+1][y1] -= c`
>    - `b[x1][y2+1] -= c`
>    - `b[x2+1][y2+1] += c`。
>
> 3. **二维前缀和还原**：通过计算 `b` 的二维前缀和得到修改后的 `a` 矩阵145。
>
> ```cpp
> int n, m, a[N][N], b[N][N];
> cin >> n >> m;
> for (int i = 1; i <= n; i++) {
>     for (int j = 1; j <= m; j++) {
>         cin >> a[i][j];
>         b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1];  // 初始化差分矩阵
>     }
> }
> int x1, y1, x2, y2, c;
> cin >> x1 >> y1 >> x2 >> y2 >> c;
> b[x1][y1] += c;             // 左上角加c
> b[x2+1][y1] -= c;           // 右下角下方减c
> b[x1][y2+1] -= c;           // 右下角右方减c
> b[x2+1][y2+1] += c;         // 右下角右下角加c（补偿多减部分）
> 
> // 二维前缀和还原
> for (int i = 1; i <= n; i++) {
>     for (int j = 1; j <= m; j++) {
>         b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
>         cout << b[i][j] << " ";
>     }
>     cout << endl;
> }
> 
> ```
>
> 或者是下面这种方法
>
> 1. 逐行做差分
> 2. 逐行还原（求前缀和）
>
> ```cpp
> int n,m;
> int a[N][N];		//差分数组
>   scanf("%d%d",&n,&m);
>   while(m--){
>     int x1,y1,x2,y2;
>     scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
>     for(int i=x1; i<=x2; i++){
>       a[i][y1]++;
>       a[i][y2+1]--; //逐行差分
>     }
>   }
> 
>   for(int i=1; i<=n; i++){
>     for(int j=1; j<=n; j++){
>       a[i][j]+=a[i][j-1];   //逐行还原
>       printf("%d ",a[i][j]);
>     }
>     puts("");
>   }
> ```
>
> # 树上差分
>
> ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424191229894-968678873.png)
>
> ```cpp
> // 定义全局变量
> VI dep(30), s(1010), a(1010); // dep: 每个节点的深度, s: 前缀和数组, a: 节点权值数组
> vector<array<int, 2>> e[1010]; // 邻接表存储树的边，array<int, 2> 表示边的目标节点和权值
> VI<VI> fa(1010, VI(20, 0)); // fa[u][i]: 节点 u 的第 2^i 个祖先
> 
> // 深度优先搜索 (DFS) 初始化节点的深度和前缀和
> void dfs(int u, int father, int t) {
>     dep[u] = dep[father] + 1; // 当前节点 u 的深度为父节点的深度加 1
>     fa[u][0] = father; // 节点 u 的第 1 个祖先是 father
>     for (int i = 1; i <= 19; i++) {
>         // 通过动态规划计算 fa[u][i]，即节点 u 的第 2^i 个祖先
>         fa[u][i] = fa[fa[u][i - 1]][i - 1];
>     }
>     // 遍历节点 u 的所有邻接节点
>     for (auto [v, x] : e[u]) { // v: 邻接节点, x: 边权值
>         if (v != father) { // 避免回到父节点
>             s[v] = x - t; // 当前节点的前缀和 = 父节点的前缀和 + 边权值
>             dfs(v, u, x); // 递归处理子节点
>         }
>     }
> }
> 
> // 求解两个节点 u 和 v 的最近公共祖先 (LCA)
> int lca(int u, int v) {
>     if (dep[u] < dep[v]) swap(u, v); // 确保 u 的深度不小于 v
>     // 将 u 提升到与 v 相同的深度
>     for (int i = 19; i >= 0; i--) {
>         if (dep[fa[u][i]] >= dep[v]) {
>             u = fa[u][i];
>         }
>     }
>     if (u == v) return v; // 如果 u 和 v 相同，则返回 u 或 v
>     // 同时向上跳跃，直到找到最近公共祖先
>     for (int i = 19; i >= 0; i--) {
>         if (fa[u][i] != fa[v][i]) { // 如果 u 和 v 的第 2^i 个祖先不同
>             u = fa[u][i]; // u 跳到第 2^i 个祖先
>             v = fa[v][i]; // v 跳到第 2^i 个祖先
>         }
>     }
>     return fa[u][0]; // 返回最近公共祖先
> }
> 
> // 深度优先搜索 (DFS) 统计答案
> void dfs2(int u, int f) {
>     for (auto [v, x] : e[u]) { // 遍历所有子节点
>         if (v != f) { // 避免回到父节点
>             dfs2(v, u); // 递归处理子节点
>             s[u] += s[v]; // 累加子节点的值到当前节点
>         }
>     }
> }
> 
> // 计算两个节点 u 和 v 的路径权值和
> int qj(int u, int v, int x) {
>     int t = lca(u, v); // 找到 u 和 v 的最近公共祖先
>     // 更新路径权值和
>     s[u] += x; // 更新节点 u 的前缀和
>     s[v] += x; // 更新节点 v 的前缀和
>     s[t] -= x; // 减去最近公共祖先的权值
>     s[fa[t][0]] -= x; // 减去最近公共祖先父节点的权值
>     //s[t]-=2*x;//边差分时
> }
> ```

# 8.ST表

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424204025607-774931047.png)

```cpp
// 定义一个二维数组 f，用于存储区间的最大值
int f[1000][20]; 

// 初始化 f[i][0]，表示每个单独元素的值
for (int i = 1; i <= n; i++) 
    cin >> f[i][0]; // 输入数组的第 i 个元素，存储在 f[i][0]

// 使用动态规划计算 f[i][j]，表示从位置 i 开始，长度为 2^j 的区间的最大值
for (int j = 1; j <= 20; j++) { // 枚举区间长度的指数 j
    for (int i = 1; i + (1 << j) - 1 <= n; i++) { // 确保区间 [i, i + 2^j - 1] 不越界
        // f[i][j] 的值是区间 [i, i + 2^j - 1] 的最大值
        // 它可以通过合并两个长度为 2^(j-1) 的子区间的最大值得到
        f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
    }
}
```

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424204733998-604575315.png)

```cpp
// 实现稀疏表查询的函数，用于查询区间 [l, r] 的最大值
int find(int l, int r) {
    // 计算区间长度的对数值 k，使得 2^k 是小于等于区间长度的最大值
    int k = log2(r - l + 1);

    // 返回区间 [l, r] 的最大值
    // 通过比较两个长度为 2^k 的子区间的最大值来实现
    // f[l][k] 表示从位置 l 开始，长度为 2^k 的区间的最大值
    // f[r - (1 << k) + 1][k] 表示从位置 r - 2^k + 1 开始，长度为 2^k 的区间的最大值
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}
```

# 9.快速排序

这个在各大语言中都有定义**sort()**来排序，这个sort就是基于快排的算法。所有一般在比赛中不需要你去手写sort，直接调用**sort**()函数即可，不过你可以不会但一定要知道原理。

快速排序主要利用**分治思想**，时间复杂度 O$(nlogn)$ 

1.令指针$i,j$指向数列的区间外侧，数列的中值记为x(这个x不一定是要为中值，也可以是别的位置的值）。

2.将数列中$\leq x$的数放左段，$\geq x$的数放右段。

3.对于左右两段，再递归以上两个过程，直到每段只有一个数，即全部有序。

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424210606554-197129885.png)

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424211546264-2085467589.png)

```cpp
// 快速排序函数
// 参数说明：
// q[]: 待排序的数组
// l: 当前排序区间的左边界
// r: 当前排序区间的右边界
void quick_sort(int q[], int l, int r)
{
    // 如果区间长度小于等于 1，则直接返回（递归终止条件）
    if (l >= r) return;

    // 初始化双指针 i 和 j，以及基准值 x
    // i 初始化为 l - 1，表示左边界的前一个位置
    // j 初始化为 r + 1，表示右边界的后一个位置
    // x 为当前区间的中间值（基准值），用于划分区间
    int i = l - 1, j = r + 1, x = q[(l + r) >> 1];

    // 循环划分区间，直到 i 和 j 相遇
    while (i < j)
    {
        // 从左向右找到第一个大于等于基准值的元素
        do i++; while (q[i] < x);

        // 从右向左找到第一个小于等于基准值的元素
        do j--; while (q[j] > x);

        // 如果 i 和 j 尚未相遇，则交换 q[i] 和 q[j]
        if (i < j) swap(q[i], q[j]);
    }

    // 递归对左半部分和右半部分进行快速排序
    quick_sort(q, l, j);     // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}
```



> [!tip]
>
> 1.如果每次选的x，能让左右两段近似等分，会生成一颗有logn层的均衡的二叉树，每层i,j两指针将会遍历所有n个元素，时间复杂度为$\operatorname{O}(nlogn)$。
> 2.如果每次选的x，只能分离出一个元素，会退化成有$n$层的链，$i,j$两指针走的总步数$=n+(n-1)+\cdots+1=\frac{(n+1)n}2$, 时间复杂度退化为 O$(n^2)$。
>
> ![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424210911599-1359536015.png)
>
> 3.c++的STL 已经实现了高效率的快排函数：**sort(a,a+n)**。

# 10.归并排序

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424211853079-1093873450.png)

```cpp
void merge_sort(int q[], int l, int r)
{
    // 如果区间长度小于等于 1，则直接返回（递归终止条件）
    if (l >= r) return;

    // 计算当前区间的中点位置
    int mid = l + r >> 1;

    // 递归对左半部分进行归并排序
    merge_sort(q, l, mid);

    // 递归对右半部分进行归并排序
    merge_sort(q, mid + 1, r);

    // 合并两个有序区间
    int k = 0, i = l, j = mid + 1;

    // 使用双指针比较两个区间的元素，将较小的元素放入临时数组 tmp[]
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];

    // 如果左半部分还有剩余元素，将其全部放入 tmp[]
    while (i <= mid) tmp[k++] = q[i++];

    // 如果右半部分还有剩余元素，将其全部放入 tmp[]
    while (j <= r) tmp[k++] = q[j++];

    // 将临时数组 tmp[] 中的排序结果拷贝回原数组 q[] 的区间 [l, r]
    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}
```

# 11.堆与堆排序

**堆**：是一颗完全二叉树。

**小根堆**：父结点的值$\leq$其子结点的值。

**大根堆**：父结点的值$\geq$其子结点的值。

对节点使用左右孩子编号法：

1. 结点i的左孩子是 2i

2. 结点 i 的右孩子是 2i+1

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424212606961-934590513.png)

堆(完全二叉树)可以用一维数组存储。

![image-20250424212730180](C:\Users\czq48\AppData\Roaming\Typora\typora-user-images\image-20250424212730180.png)

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424212806089-24451079.png)

```cpp
// 上浮操作，用于维护最小堆的性质
void up(int u) {
    // 如果当前节点有父节点（u/2 > 0），并且父节点的值大于当前节点的值
    if (u / 2 && a[u / 2] > a[u]) {
        // 交换当前节点与父节点的值
        swap(a[u], a[u / 2]);
        // 递归向上调整父节点，继续维护堆的性质
        up(u / 2);
    }
}

// 插入操作，将新元素插入到最小堆中
void push(int x) {
    // 将新元素插入堆的末尾（堆的大小增加 1）
    a[++cnt] = x;
    // 调用上浮操作，从新插入的节点开始向上调整
    up(cnt);
}
```

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424213147171-101844441.png)

```cpp
// 下沉操作，用于维护最小堆的性质
void down(int u) {
    int v = u; // 初始化当前节点为 u
    // 如果左子节点存在且小于当前节点，则更新 v 为左子节点
    if (u * 2 <= cnt && a[u * 2] < a[v]) v = u * 2;
    // 如果右子节点存在且小于当前节点（或左子节点），则更新 v 为右子节点
    if (u * 2 + 1 <= cnt && a[u * 2 + 1] < a[v]) v = u * 2 + 1;
    // 如果 v 发生了变化（即当前节点不是最小值），交换当前节点与子节点的值
    if (u != v) {
        swap(a[u], a[v]); // 交换当前节点与子节点
        down(v); // 递归向下调整子节点，继续维护堆的性质
    }
}

// 删除堆顶元素（最小值）操作
void pop() {
    a[1] = a[cnt--]; // 将堆的最后一个元素移动到堆顶，并减少堆的大小
    down(1); // 从堆顶开始向下调整，维护最小堆的性质
}
```

> [!tip]
>
> 在c++的STL中优先队列(priority_queue)可以看作是一个堆

# 12.对顶堆

![](https://img2024.cnblogs.com/blog/3517627/202504/3517627-20250424214148863-988077388.png)

# 13.中位数定理



## 一、定义

**中位数定理**（Median Theorem）指出：
在一维实数数据集中，中位数是使所有数据点到该点的绝对偏差（即距离绝对值之和）最小的唯一位置。
 数学表达：对数据集 $x_1, x_2, \ldots, x_n$，中位数 $M$ 满足：
$$\sum_{i=1}^{n} |x_i - M| \leq \sum_{i=1}^{n} |x_i - c| \quad (\forall c \in \mathbb{R})$$

## 二、核心性质

1. ==绝对偏差最小化==
**中位数是唯一使所有数据点到其距离总和最小的点（若数据量为偶数，则区间内任意点均满足，但通常取中间两数均值）**。

2. 抗极端值干扰
中位数对数据中的极大或极小值不敏感，而平均数会受其显著影响。
示例：数据集 {1, 2, 3, 4, 100} 的中位数为 3，平均数为 22。

3. 平衡性
中位数将数据集分为左右两部分，左右两侧的数据点数量相等（或相差不超过1）。

## 三、证明思路（以数轴为例）

目标：证明中位数 $M$ 是使总绝对偏差最小的点。

步骤1：排序数据点

将数据按大小排序为 $x_{(1)} \leq x_{(2)} \leq \ldots \leq x_{(n)}$，中位数 $M = x_{(k)}$，其中 $k = \lfloor (n+1)/2 \rfloor$。

步骤2：分析移动中位数的影响

假设当前点为 $c$，且 $c < M$（位于中位数左侧）：
- 左侧点数：小于 $c$ 的点数 $\leq$ 左侧总点数的一半。
- 右侧点数：大于 $c$ 的点数 $\geq$ 右侧总点数的一半。
- 结论：向右移动 $c$ 会减少右侧更多点的距离，总偏差减小，直到 $c = M$。

同理，若 $c > M$，向左移动会减少总偏差。

步骤3：平衡状态

当 $c = M$ 时：
- 左侧和右侧点数相等（或相差1），任何移动都会导致一侧距离增加超过另一侧减少，总偏差最小。

# 14.曼哈顿距离

曼哈顿距离( Manhattan Distance) 即为两点在各坐标轴上的**绝对差之和**，公式为：

![](https://storage.simpletex.cn/view/f4BZfORsETSiW04F4IuL02H9AaclC0VVh)

对于 **二维空间** 中的两点 *P*(*x*1,*y*1) 和 *Q*(*x*2,*y*2)，曼哈顿距离的公式为：**D(A,B)=∣*x*1−*x*2∣+∣*y*1−*y*2∣**

切比雪夫距离即为**两点在各坐标轴上的绝对差的最大值**，其定义如下：
$$
A(x_1, y_1),\ B(x_2, y_2) \\
d(A, B) = \max \left\{ |x_1 - x_2|,\ |y_1 - y_2| \right\}
$$

$\textcolor{red}{曼哈顿距离与切比雪夫距离可以相互转化}：$
$$
\begin{aligned}
D_{\text{max}}(A, B) &= |x_1 - x_2| + |y_1 - y_2| \\
&= \max \begin{cases}
x_1 - x_2 + y_1 - y_2, \\
x_1 - x_2 + y_2 - y_1, \\
x_2 - x_1 + y_1 - y_2, \\
x_2 - x_1 + y_2 - y_1
\end{cases} \\
&= \max \left\{ \left| (x_1 + y_1) - (x_2 + y_2) \right|,\ \left| (x_1 - y_1) - (x_2 - y_2) \right| \right\} \\
&= d\left( (x_1 + y_1, x_1 - y_1),\ (x_2 + y_2, x_2 - y_2) \right)
\end{aligned}
$$

坐标变换定义
令：
$$
A'(x_1 + y_1, x_1 - y_1),\ \ B'(x_2 + y_2, x_2 - y_2)
$$

# 15.双指针（尺取法）

双指针法是一种用于解决序列区间问题的优化技巧，通过两个指针`i`和`j`在序列上的不同扫描方式实现高效操作。主要分为两种扫描方向：

## 1. 反向扫描

- **指针方向**：`i`与`j`方向相反，`i`从头到尾扫描，`j`从尾到头扫描。
- **终止条件**：两者在序列中间相会时结束。
- **典型应用**：有序数组的两数之和、回文串判断等对称性问题。

## 2. 同向扫描（快慢指针）

- **指针方向**：`i`和`j`方向相同，均从头到尾扫描，且`j`通常移动更快。

- **滑动窗口**：快慢指针在序列上形成一个大小可变的窗口，适用于子区间问题。

- 典型应用

  ：

  - 数组去重（保留固定重复次数）
  - 最小/最大连续子数组和
  - 链表环检测与中间节点定位

> [!tip]
>
> 异或和是不进位的加法，有 a⊕b ≤ a + b，当二进制的同位数字不同时为 1 时，才取等号。

# 16.贪心

