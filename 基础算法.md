# 基础算法

> [!NOTE]
>
> 代码模板                  
>
> `````cpp
> #include<bits/stdc++.h>
> using namespace std;
> const int N=1e5+10;
> const int mod=1e9+7;
> #define VI vector<int>
> void solve(){
> 
> }
> int main(){
> 	int t=1;
> 	//cin>>t;
> 	while(t--)solve();
>     return 0;
> }
> `````
>
> 

# 1.高精度加法

高精度加法是通过一个数组来存储每一位，然后再按正常的加法进行相加，个位加个位，十位加十位，...,有进位加进位。但是对于相加的两个数字，我们不能够直接去按正序存储，我们应该倒序存储，然后实现相加,最后我们还有倒序输出才是正解。

`````cpp
VI a,b,c;
void add(string sa,string sb){			//sa和sb为相加的两个数字，因int存不下，所有用数组存
    for(int i=sa.size()-1;~i;i--)a.push_back(sa[i]-'0');	//将数字倒序存进a中
    for(int i=sb.size()-1;~i;i--)b.push_back(sb[i]-'0');	//将数字倒序存进b中
    int t=0,i=0;
    for(i=0;i<min(a.size(),b.size());i++){
        t+=a[i]+b[i];				//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);			//存入相加的对应位上的余数
        t/=10;						//存上进位
    }
    while(i<a.size()){
        t+=a[i];					//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);			//存入相加的对应位上的余数
        t/=10;						//存上进位
        i++;
    }
    while(i<b.size()){
        t+=b[i];					//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);			//存入相加的对应位上的余数
        t/=10;						//存上进位
        i++;
    }
    if(t)c.push_back(t);			//最后再看看t是否为0，来判断是否要再加一位
}
`````

> [!tip]
>
> 在C++中，`~i`表示对变量`i`进行**按位取反**操作。具体表现为：将`i`的二进制每一位（包括符号位）取反（0变1，1变0）。
> 对于**有符号数**其数学规律可总结为：`~i = -i - 1`;
> 对于**无符号数**其数学规律课总结为：`~i = (2ⁿ - 1) - i`。
>
> ### 原理解析
>
> **按位取反操作** 是对一个整数的每一位二进制数进行取反，即将0变为1，1变为0。这一操作适用于所有整数类型，但处理方式会因数的符号（有符号还是无符号）而有所不同。
>
> #### 正数的按位取反
>
> 对于正数，按位取反操作直接对其二进制表示进行取反。例如：
>
> - **十进制5** ：二进制表示为`00000101`
> - **按位取反** ：`11111010`
> - **十进制结果** ：-6（在**补码**表示下）
>
> 这是因为计算机中的整数通常采用补码表示法，对于正数，其补码与其原码相同。取反后的结果加上1（即补码的求法）会得到对应的负数。
>
> #### 负数的按位取反
>
> 对于负数，按位取反同样是对二进制表示进行取反，但需要注意的是，负数在计算机中是以补码形式存储的。例如：
>
> - **十进制-2** ：二进制补码表示为`11111110`
> - **按位取反** ：`00000001`
> - **十进制结果** ：1
>
> 这里的关键在于补码的性质：负数的补码是其绝对值的二进制表示取反后加1。因此，取反后再加1会恢复到原来的正数。
>
> #### 无符号数的按位取反
>
> 对于无符号数，按位取反也是直接对每一位进行取反，但不会考虑符号位。例如：
>
> - **无符号数5** （假设8位）：二进制表示为`00000101`
> - **按位取反** ：`11111010`
> - **十进制结果** ：250（在无符号8位表示下）
>
> 无符号数没有符号位的概念，因此取反后的结果仍然是一个有效的无符号数。

# 2.高精度减法

这个与高精度加法相似，就是要判断是前者大还是后者大，来考虑是否输出负号和交换顺序

```cpp
VI a,b,c;
void sub(string sa,string sb){	//sa和sb为相加的两个数字，因int存不下，所有用数组存
    if(sa.size()<sb.size()||(sa.size()==sb.size()&&sa<sb)){cout<<'-';swap(sa,sb);}	//保证大数在前，用大数减小树
    for(int i=sa.size()-1;~i;i--)a.push_back(sa[i]-'0');	//将数字倒序存进a中
    for(int i=sb.size()-1;~i;i--)b.push_back(sb[i]-'0');	//将数字倒序存进b中
    int i=0;
    for(i=0;i<b.size();i++){
        if(a[i]<b[i])a[i+1]--,a[i]+=10;						//如果大数的该位小就先借位
        c.push_back(a[i]-b[i]);
    }
    while(i<a.size()) {						//将剩余的a中的位数存进去
        if(a[i]<0){							//如果大数的该位被借位成了负数就要先借位       这个很重要
            a[i+1]--;
            a[i]+=10;
        }
        c.push_back(a[i++]);
        }
    //因为相减，所以可能出现前面多个零的情况，因此要去除前导零
    while(c.size()-1!=0&&!c.back())c.pop_back();
}
```

# 3.高精度乘法

高精度乘法的核心是模拟手工竖式乘法，逐位相乘和错位累加，即用双重循环遍历两个乘数的每一位，执行`a[i] * b[j]`，并将结果累加到乘积数组的`c[i+j]`位置，==注意要对c[i+j]处理进位的情况==，最后再去除前导零。

```cpp
VI a,b,c;
void mul(string sa,string sb){
    for(int i=sa.size()-1;~i;i--)a.push_back(sa[i]-'0');		//将数字倒序存进a中
    for(int i=sb.size()-1;~i;i--)b.push_back(sb[i]-'0');		//将数字倒序存进b中
    c.resize(a.size()+b.size()+1);
    for(int i=0;i<a.size();i++){
        for(int j=0;j<b.size();j++){
            c[i+j]+=a[i]*b[j];				//存乘积
            c[i+j+1]+=c[i+j]/10;			//存进位
            c[i+j]%=10;						//存余数
        }
    }
    while(c.size()>1&&!c.back())c.pop_back();		//去除前导零
}
```

# 4.高精度除法

高精度除法的核心是模拟手工竖式除法

## 高精度除以低精度

从被除数的最高位开始，逐位进行除法运算。具体做法是，将当前的余数乘以 10 再加上当前位的数字，然后用这个结果除以除数，得到商的当前位，同时更新余数，注意去除前导零。

```cpp
VI a,b,c;
void div(string sa,int b){
    for(int i=0;i<sa.size();i++)a.push_back(sa[i]-'0');		//将被除数存进a中
    c.resize(a.size());
    long long t=0;
    for(int i=0;i<a.size();i++){
       t=t*10+a[i];		//存被除数
       c[i]=t/b;		//存商
       t%=b;			//存余数
    }
    while(c.size()>1&&!c[0])c.erase(c.begin());		//去除前导零
}

```

# 5.二分查找

二分查找（Binary Search）是一种在**有序数组**中快速查找目标元素的高效算法。
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值，其时间复杂度为 **O(log n)**。
这个一般是最小求最大，最大求最小的情况下用的多

## **核心原理**

1. **有序前提**：数组必须已排序（升序或降序）。
2. 分治策略：通过不断缩小搜索范围，每次比较中间元素与目标值：
   - 若中间元素等于目标 → 查找成功。
   - 若中间元素小于目标 → 在右半部分继续查找。
   - 若中间元素大于目标 → 在左半部分继续查找。

> [!tip]
>
> 在c++的STL库中有提供:
> `lower_bound(begin, end, value, cmp)`来查找第一个==大于等于==value的值;
> `upper_bound(begin, end, value, cmp)`来查找第一个==大于==value的值。
>
> 还有这两个函数的返回值返回的是查找到的值的地址，不是值。
>
> ### 参数列表
>
> 1. **起始迭代器（`begin`）**
>    表示搜索范围的起始位置，通常为容器（如`vector`、`array`等）的`begin()`迭代器。需与`end`共同定义左闭右开区间`[begin,end)`。
> 2. **结束迭代器（`end`）**
>    表示搜索范围的结束位置，通常为容器的`end()`迭代器。若容器为空或未找到目标值，函数返回此迭代器。
> 3. **目标值（`value`）**
>    需要查找的元素值。其类型必须与容器元素的类型兼容，或可通过隐式转换匹配。例如，在`vector<int>`中查找整数时，`value`应为`int`类型。
> 4. **比较函数（`cmp`，可选）**
>    自定义比较规则的回调函数或函数对象，用于定义元素的排序逻辑。默认使用`<`运算符进行比较。若容器按降序排列，需显式传递`greater<type>()`等函数对象以匹配实际排序方式
>
> ### 举例
>
> ```cpp
>   int a[10]={0,1,2,3,4,5,6,7,8,9};
>   int t=*lower_bound(a,a+10,5);	//t=5
>   t=*upper_bound(a,a+10,5);		//t=6
>   vector<int>b{0,1,2,3,4,5,6,7,8,9};
>   t=*lower_bound(b.begin(),b.end(),5);		//t=5
>   t=*upper_bound(b.begin(),b.end(),5);		//t=6
> ```
>
> 

## 二分查找各个模板

### 模板1

当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
```cpp
int find(int l, int r)
{
    while (l < r)	//l==r时结束
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

### 模板2

当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。

```cpp
int find(int l, int r)
{
    while (l < r)	//l==r是结束
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 模板3

```cpp
int find(){
  int l=0,r=n+1;	//开区间
  while(l+1<r){ 	//l+1=r时结束
    int mid=l+r>>1;
    if(check(mid)) r=mid; 	//最小化
    else l=mid;
  }
  return check(r) ? r : -1;
}
```

### 模板4

```cpp
int find(){
  int ans=0;
  int l=1,r=n; //闭区间
  while(l<=r){ //l=r+1时结束
    int mid=l+r>>1;
    if(check(mid)) ans=mid,r=mid-1; //最小化
    else l=mid+1;
  }
  return check(ans) ? ans : -1;
}
```

# 6.前缀和

