# 基础算法

> [!NOTE]
>
> 代码模板
>
> `````cpp
> #include<bits/stdc++.h>
> using namespace std;
> const int N=1e5+10;
> const int mod=1e9+7;
> #define VI vector<int>
> void solve(){
> 
> }
> int main(){
> 	int t=1;
> 	//cin>>t;
> 	while(t--)solve();
>     return 0;
> }
> `````
>
> 

# 1.高精度加法

高精度加法是通过一个数组来存储每一位，然后再按正常的加法进行相加，个位加个位，十位加十位，...,有进位加进位。但是对于相加的两个数字，我们不能够直接去按正序存储，我们应该倒序存储，然后实现相加,最后我们还有倒序输出才是正解。

`````cpp
VI a,b,c;
void add(string sa,string sb){//sa和sb为相加的两个数字，因int存不下，所有用数组存
    for(int i=sa.size()-1;i>=0;i--)a.push_back(sa[i]-'0');//将数字倒序存进a中
    for(int i=sb.size()-1;i>=0;i--)b.push_back(sb[i]-'0');//将数字倒序存进b中
    int t=0,i=0;
    for(i=0;i<min(a.size(),b.size());i++){
        t+=a[i]+b[i];//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);//存入相加的对应位上的余数
        t/=10;//存上进位
    }
    while(i<a.size()){
        t+=a[i];//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);//存入相加的对应位上的余数
        t/=10;//存上进位
        i++;
    }
    while(i<b.size()){
        t+=b[i];//上一位两数相加的进位加上现在的对应位上的数字
        c.push_back(t%10);//存入相加的对应位上的余数
        t/=10;//存上进位
        i++;
    }
    if(t)c.push_back(t);
}
`````

# 2.高精度减法

这个与高精度加法相似，就是要判断是前者大还是后者大，来考虑是否输出负号和交换顺序

```cpp
VI a,b,c;
void sub(string sa,string sb){//sa和sb为相加的两个数字，因int存不下，所有用数组存
    if(sa.size()<sb.size()||(sa.size()==sb.size()&&sa<sb)){cout<<'-';swap(sa,sb);}//保证大数在前，用大数减小树
    for(int i=sa.size()-1;i>=0;i--)a.push_back(sa[i]-'0');//将数字倒序存进a中
    for(int i=sb.size()-1;i>=0;i--)b.push_back(sb[i]-'0');//将数字倒序存进b中
    int i=0;
    for(i=0;i<b.size();i++){
        if(a[i]<b[i])a[i+1]--,a[i]+=10;//如果大数的该位小就先借位
        c.push_back(a[i]-b[i]);
    }
    while(i<a.size()) {//将剩余的a中的位数存进去
        if(a[i]<0){//如果大数的该位被借位成了负数就要先借位       这个很重要
            a[i+1]--;
            a[i]+=10;
        }
        c.push_back(a[i++]);
        }
    //因为相减，所以可能出现前面多个零的情况，因此要去0
    while(c.size()-1!=0&&!c.back())c.pop_back();
}
```

# 3.高精度乘法

