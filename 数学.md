# 数学模板

[TOC]



## 1.快速幂

使用`二进制拆分`和`倍增`的思想，将O(n)优化到O(logn)

```cpp
int quickpow(int a,int n){
    int res=1;
    while(n){
        if(n&1)res=res*a;
        a=a*a;
        n>>=1;
    }
    return res;
}
```

## 2.高精度快速幂

采用vector<int>来存储数据，按照正常的乘法来逐位相乘，从而实现计算过程

```cpp
#define vi vector<int>
const int N=105;
vi a(N);
vi operator *(vi a,vi b){
  vi t(N*2);
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++){
            t[i+j]+=a[i]*b[j];
            t[i+j+1]+=t[i+j]/10;
            t[i+j]%=10;
        }
    return t;
}
vi quickpow(vi a,int n){
    vi res(N,0);
    res[0]=1;
    while(n){
        if(n&1)res=res*a;
        a=a*a;
        n>>=1;
    }
    while(res[res.size()-1]==0)res.pop_back();
    reverse(res.begin(),res.end());
    return res;
}
int main(){
    int x,n;cin>>x>>n;
    int i=0;
    while(x){
        a[i++]=x%10;
        x/=10;
    }
    a=quickpow(a,n);
    for(auto i:a)cout<<i;
    return 0;
}
```

## 3.矩阵快速幂

对于n*n的矩阵之间相乘，也可以使用快速幂的形式

```cpp
#define ll long long
const int mod=1e9+7;
struct matrix{
    ll c[101][101];
    matrix(){memset(c,0,sizeof c);}
}a,res;
ll n,k;
matrix operator*(matrix &x,matrix &y){
    matrix t;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                t.c[i][j]=(t.c[i][j]+x.c[i][k]*y.c[k][j])%mod;
    return t;
}

void quickpow(ll k){
    for(int i=1;i<=n;i++)res.c[i][i]=1;//按需更改
    while(k){
        if(k&1)res=res*a;
        a=a*a;
        k>>=1;
    }
}
```

## 4.最大公约数

欧几里得算法（辗转相除法）

如果是c++可以调用`__gcd()`函数。

```cpp
LL gcd(LL a, LL b){
  return b==0 ? a : gcd(b,a%b);
}

//非递归
LL gcd(LL a, LL b){
  while(b){
      LL t=b;
      b=a%b;
      a=t;
  }
    return a;
}
```

## 5.判断质数

==质数==：约数只有1和他自身的整数，被称为质数或素数

例如,2,3,5,7,11...

注意`1不是质数`

暴力做法，枚举从小到大的每个数看是否能整除，时间复杂度是$O(n)$。

事实上，如果$a$是$n$的约数，那么$\frac na$也是$n$的约数。对于每一对$\left(a,\frac na\right)$,只需要检验其中小的那个数，所有较小的数就在这个区间$[1,\sqrt{n}]$。所以时间复杂度是$\color{red}{O}(\sqrt{n})$

```cpp
bool is_zhi(int x){
    if(x==1)return false;
    for(int i=2;i*i<=n;i++)
        if(x%i==0)return 0;
    return 1;
}
```

## 6.分解质因数

==算术基本定理(唯一分解定理)==：每个正整数都能够唯一的表示成它的质因数的乘积。

$$n={p_1}^{\alpha_1}{p_2}^{\alpha_2}\cdots{p_s}^{\alpha_s},\:p_1<p_2<\cdots<p_s$$

例如，280$=2^3*5^1*7^1$

==n 中最多只含有一个大于$\sqrt n$ 的因子==
反证法：如果有两个大于 $\sqrt{n}$ 的因子，则相乘会大于$n$

==分解质因数==
在 2~$\sqrt{n}$范围枚举，

遇到质因子就除净并且记录质因子的个数。
最后如果$n>1$,说明这就是那个大于$\sqrt{n}$的质因子。

```cpp
int a[1001];
void decompose(int x){
    for(int i=2;i*i<=x;i++)
        while(x%i==0)a[i]++,x/=i;
    if(x>1)a[x]++;
}
```

## 7.筛质数

### 一.埃氏筛法

从小到大枚举每个数

如果当前数没划掉，必定是质数，记录该质数
枚举当前质数的倍数，必定是合数，划掉合数

```cpp
int vis[N];//真为合数
int prim[N];//记录质数
int cnt;//质数个数
void Eratosthenes(int n){
    for(ll i=2;i<=n;i++){
        if(!vis[i]){
            prim[++cnt]=i;
            for(ll j=i*i;j<=n;j+=i)
                vis[j]=1;
        }
    }
}
```

### 二.线性筛法（欧拉筛法）

从小到大枚举每个数
1.如果当前数没划掉，必定是质数，记录该质数
2.枚举已记录的质数(如果合数已越界则中断)

(1)合数未越界，则划掉合数

> (2) 条件 $i\% p= = 0$, 保证合数只被最小质因子划掉
>
> > 若i是质数，则最多枚举到自身中断
> > 若i是合数，则最多枚举到自身的最小质数中断

```cpp
int vis[N];//真为合数
int prim[N];//记录质数
int cnt;//质数个数
void get_prim(int n){
    for(int i=2;i<=n;i++){
        if(!vis[i])prim[++cnt]=i;
        for(int j=1;1ll*i*prim[j]<=n;j++){
            vis[i*prim[j]]=1;
            if(i%prim[j]==0)break;
        }
    }	
}
```

## 8.线性筛法求约数个数

给一个数$n\left(n\leq1\times10^6\right)$,输出1~$n$每个数的约数个数。

==约数个数定理==

> 若  $n= \prod _{i= 1}^{s}p_{i}^{\alpha _{i}}$,则$d(n)=\prod_{i=1}^{s}(\alpha_{i}+1)$。
> 证明：$p_i^{\alpha_t}$的约数有$p_i^0,p_i^1,\cdots,p_i^{\alpha_i}$共$(\alpha_i+1)$个，
> 根据乘法原理，$d(n)=\prod_{i=1}^s(\alpha_i+1)$。

==筛法求约数个数==

> 若$i$是质数，$a[i]=1$,d$[i]=2$。
> 在线性筛中，每个合数$m$都是被最小的质因子筛掉的。设$p_j$是$m$的最小质因子，则$m$通过$m=p_j\times i$筛掉。
> (1)若$i$能被$p_j$整除，则$p_j$一定是$i$的最小质因子。
> $a[m]=a[i]+1;$
> $d[i]=(a[i]+1)\times\cdots,d[m]=(a[m]+1)\times\cdots$ 
> (2)若$i$不能被$p_j$整除，则$i$不包含质因子$p_j$。
> $$a[m]=1,d[m]=d[i]\times(1+1)$$

```cpp
int p[N],vis[N],cnt;
int a[N];//记录i的最小质因子的个数
int d[N];//记录i的约数个数
void get_d(int n){
    d[1]=1;
    for(int i=2;i<=n;i++){
        if(!vis[i]){
            p[++cnt]=i;
            a[i]=1;
            d[i]=2;
        }
        for(int j=1;i*p[j]<=n;j++){
            int m=i*p[j];
            vis[m]=1;
            if(i%p[j]==0){
                a[m]=a[i]+1;
                d[m]=d[i]/a[m]*(a[m]+1);
                break;
            }
            else a[m]=1,d[m]=d[i]*2;
        }
    }
}
```

## 9.筛法求约数和

==约数和定理==
若$n=\prod_{i=1}^\mathrm{s}p_i^{\alpha_i}$,则$f(n)=\prod_i=1^\mathrm{s}\sum_{j=0}^{\alpha_i}p_i^j$

```cpp
int p[N],vis[N],cnt;
int g[i];//g[i]表示最小质因子的约数和
int f[i];//f[i]表示i的约数和

void get_f(int n){
    g[1]=g[1]=1;
    for(int i=2;i<=n;i++){
        if(!vis[i]){
            p[cnt++]=i;
            g[i]=f[i]=i+1;
        }
        for(int j=0;i*p[j]<=n;j++){
            int m=i*p[j];
            vis[m]=1;
            if(i%p[j]==0){
                g[m]=g[i]*p[j]+1;
                f[m]=f[i]/g[i]*g[m];
                break;
            }
            else {
                g[m]=p[j]+1;
                f[m]=f[i]*g[m];
            }
        }
    }
}
```

## 10.筛法求莫比乌斯函数

莫比乌斯函数的定义

$\mu(n)=\left\{\begin{matrix}{1}&{n=1}\\{0}&{n\text{ 含相同质因子}}\\{(-1)^{s}}&{s\text{ 为 }n\text{ 的不同质因子的个数}}\\\end{matrix}\right.$
例：$\mu\{1,6,10,15\}=1,\mu\{4,8,9,12\}=0,\mu\{2,3,5,7,30\}=-1$

```cpp
int p[N],vis[N],cnt;
int mu[N];

void get_mu(int n){
    mu[1]=1;
    for(int i=2;i<=n;i++){
        if(!vis[i]){
            p[cnt++]=i;
            mu[i]=-1;
        }
        for(int j=0;i*p[j]<=n;j++){
            int m=i*p[j];
            vis[m]=1;
            if(i%p[j]==0){
                mu[m]=0;
                break;
            }
            else {
                mu[m]=-mu[i];
            }
        }
    }
}
```

## 11.同余式

如果两整数$a,b$ 模 $m$ 的余数相同，则称$a,b$模$m$同余，
记为$\boldsymbol{a}\equiv\boldsymbol{b}\left(\boldsymbol{modm}\right)$。例：$\boldsymbol{8}\equiv2\left(\boldsymbol{mod}3\right)$

## 12.乘法逆元

若$a,b$互质，且满足同余方程$ax\equiv1(modb)$,
则称$x$为$a$ 模$b$ 的乘法逆元，记作$.a^-1$
 例：$8x\equiv1$ (mod 5),解得$x=2,7,12...$

## 13.费马小定理

若$\boldsymbol{p}$为质数，且$\boldsymbol{a},\boldsymbol{p}$互质，则$a^p-1\equiv1({\mathrm{mod~}}p)$
$\textbf{例 : }4^{3- 1}\equiv 1( {\mathrm{mod}} 3)$

==问题==

给两个数 a,p 是质数，求 a 模 p 的乘法逆元

由费马小定理

$a^{p- 1}\equiv 1\left ( mod\right . p$) , 得  $a\times a^{p- 2}\equiv 1\left ( mod\right . p)$
所以$a^{p-2}$就是$a$ 模 $p$ 的乘法逆元。

用快速幂求即可。

```cpp
quickpow(a,p-2,p);
```

## 14.剩余系（同余类）

给定一个正整数$n$,把所有整数根据模$n$的余数$r\in$ $[0,n-1]$分为 n 类，每一类表示为$C_r=nx+r$的形式，这类数所构成的一个集合称为模$n$的剩余类。
例$n=5,r=3$,则$C_3=5x+3$为模5的一个剩余类。

## 15.完全剩余系（完系）



给定一个正整数$n$,有$n$个不同的模$n$的剩余类， 从这$n$个不同的剩余类中各取出一个元素，总共$n$ 个数，将这些数构成一个新的集合，则称这个集合为模$n$的完全剩余系。
例$n=5$,则$\{0,1,2,3,4\}$是一个模 5 的完全剩余系，
$\{5,1,-3,8,9\}$也是一个模 5 的完全剩余系。

## 16.简化剩余系(缩系)

给定一个正整数$n$,有$\boldsymbol{\varphi}(n)$个不同的模$n$的余数$r$ 与$n$ 互质的剩余类，从这 $\varphi(n)$个剩余类中各取出一个元素，总共$\varphi(n)$个数，将这些数构成一个新的集合，则称这个集合为模$n$的简化剩余系。
例$n=5$,则$\{1,2,3,4\}$是一个模 5 的简化剩余系， $n=10$,则$\{1,3,7,9\}$是一个模10的简化剩余系， 显然模$n$的简化剩余系中所有的数都与$n$互质。

## 17.欧拉函数

1~n中与n互质的数的个数称为欧拉函数，记为$\varphi(n)$

$\varphi(n)=n\times\prod_{i=1}^{S}\frac{p_{i}-1}{p_{i}}$

==欧拉定理==

 若 gcd$( a, m) = 1$,则 $a^{\varphi ( m) }\equiv 1 ( {\mathrm{mod}} m)$

例：$a=3,m=4$,则$3^\varphi(4)\equiv3^2\equiv1\pmod{4}$

​	$a=3,m=4$ $a=3,m=5$,则 $3^\varphi(5)\equiv3^4\equiv1\pmod{5}$

==扩展欧拉定理==

$$a^b\equiv\begin{cases}a^b,&\quad b<\varphi(m),&\quad(mod\:m)\\a^{bmod\:\varphi(m)+\varphi(m)},&\quad b\geq\varphi(m),&\quad(mod\:m)\end{cases}$$

当 b 小的时候，不用降幂，直接跑快速幂即可。
当 b 是大幂幂的时候，先降成小幂幂，再跑快速幂。

## 18.威尔逊定理

$\begin{array}{c}(p-1)!\equiv-1({\mathrm{mod}}p)\text{ 是 }p\text{ 为质数的充分必要条件}\end{array}$

## 19.裴蜀定理（贝祖定理）

$\begin{array}{c}\text{一定存在整数 }x,y,&\text{满足}ax+by=gcd(a,b)\end{array}$

==裴蜀定理推广==

一定存在整数$x,y$,满足$ax+by=gcd(a,b)\times n.$

例$4x+6y=8$,有整数解$x=-4,y=4$。

==裴蜀定理再推广==

一定存在整数 $X_1\cdots X_i$,满足$\sum_{i=1}^nA_iX_i=gcd(A_1,A_2,\cdots,A_n)$
例$4x_1+6x_2+2x_3=4$,有整数解$x_1=1,x_2=0,x_3=0$。

## 20.拓展欧几里得算法

当$b=0$时$ax+by=a$故而$x=1,y=0$
当$b\neq0$时
${\text{由欧几里得算法，}\gcd(a,b)}=\gcd(b,a\%b)$
由裴蜀定理，
$\gcd ( a, b) = ax$ + $by$
$\gcd(b,a\%b)=bx_1+(a\%b)y_1$
$=bx_1+(a-\left|\frac{a}{h}\right|\times b)y_1$
$=ay_1+b(x_1-\frac ahy_1)$
所以$x=y_1,y=x_1-\frac aby_1$
可以用递归算法，先求出下一层的$x_1,y_1$,
再回代到上一层，层层回代，可求特解$(x_0,y_0)$
构造通解
$$\begin{cases}x=x_0+\dfrac{b}{\gcd(a,b)}*k\\y=y_0-\dfrac{a}{\gcd(a,b)}*k\end{cases}(\text{考虑}ax+by=0\text{ 构造})$$

```cpp
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
        x=1,y=0;
        return a;
    }
    int x1,y1,d;
    d=exgcd(b,a%b,x1,y1);
    x=y1,y=x1-a/b*y1;
    return d;
}
```

==可用于求同余方程和乘法逆元==

$\text{扩欧算法}.ax+by=\gcd(a,b)\\
1.\text{ 求解不定方程 }ax+my=c\\
2.\text{ 求解同余方程 }ax\equiv b\mathrm{~(mod~}m)\\
3.\text{ 求解乘法逆元 }ax\equiv1\mathrm{~(mod~}m)$

## 21.中国剩余定理

==《孙子算经》==
七七数之剩二。问物几何？有物不知其数，三三数之剩二，五五数之剩三

==求解线性同余方程组==

$x\equiv r_1\left(mod\right.m_1)$

$x\equiv r_2\left(mod\right.m_2)$

$\vdots$

$x\equiv r_n\left(mod\right.m_n)$

其中模数$m_1,m_2,\cdots,m_n$为两两互质的整数，
求$x$的最小非负整数解。

==中国剩余定理 (Chinese Remainder Theorem, CRT)==

1. 计算所有模数的积 $M$
2. 计算第 $i$ 个方程的 $c_i = \frac{M}{m_i}$
3. 计算 $c_i$ 在模 $m_i$ 意义下的逆元 $c_i^{-1}$
4. $x = \sum_{i=1}^{n} r_i c_i c_i^{-1} (\text{mod } M)$

